; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\main.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Core\Inc -IC:\workspace\stm32_bootloader\RTE\_stm32iap -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F103xE --omf_browse=.\objects\main.crf Core\Src\main.c]
                          THUMB

                          AREA ||i.Error_Handle||, CODE, READONLY, ALIGN=1

                  Error_Handle PROC
;;;7      
;;;8      void Error_Handle(void)
000000  4770              BX       lr
;;;9      {
;;;10         //uartprintf("Kernel panic ...\n");
;;;11         //while(1);
;;;12     }
;;;13     
                          ENDP


                          AREA ||i.RCC_Init||, CODE, READONLY, ALIGN=2

                  RCC_Init PROC
;;;13     
;;;14     static void RCC_Init(void)
000000  b508              PUSH     {r3,lr}
;;;15     {
;;;16         __IO uint32_t tmpreg;
;;;17         // 辅助功能IO时钟使能
;;;18         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
000002  485b              LDR      r0,|L2.368|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0400001          ORR      r0,r0,#1
00000a  4959              LDR      r1,|L2.368|
00000c  6188              STR      r0,[r1,#0x18]
;;;19         /* Delay after an RCC peripheral clock enabling */
;;;20         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
00000e  4608              MOV      r0,r1
000010  6980              LDR      r0,[r0,#0x18]
000012  f0000001          AND      r0,r0,#1
000016  9000              STR      r0,[sp,#0]
;;;21         (void)tmpreg;
000018  bf00              NOP      
;;;22     
;;;23         // 电源接口时钟使能
;;;24         // If you don't set the RCC_APB1ENR .PWREN bit,
;;;25         // the registers of PWR unit can't be written and reading them returns 0.
;;;26         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  61c8              STR      r0,[r1,#0x1c]
;;;27         /* Delay after an RCC peripheral clock enabling */
;;;28         tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
000024  4608              MOV      r0,r1
000026  69c0              LDR      r0,[r0,#0x1c]
000028  f0005080          AND      r0,r0,#0x10000000
00002c  9000              STR      r0,[sp,#0]
;;;29         (void)tmpreg;
00002e  bf00              NOP      
;;;30     
;;;31         NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000030  2003              MOVS     r0,#3
000032  4602              MOV      r2,r0
000034  4b4f              LDR      r3,|L2.372|
000036  6819              LDR      r1,[r3,#0]
000038  f64f03ff          MOV      r3,#0xf8ff
00003c  4019              ANDS     r1,r1,r3
00003e  4b4e              LDR      r3,|L2.376|
000040  430b              ORRS     r3,r3,r1
000042  ea432102          ORR      r1,r3,r2,LSL #8
000046  4b4b              LDR      r3,|L2.372|
000048  6019              STR      r1,[r3,#0]
00004a  bf00              NOP      
;;;32     
;;;33         // 通用和复用功能I/O
;;;34         CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);  // 000：完全SWJ(JTAG-DP + SW-DP)：复位状态；
00004c  484b              LDR      r0,|L2.380|
00004e  6840              LDR      r0,[r0,#4]
000050  f02060e0          BIC      r0,r0,#0x7000000
000054  4949              LDR      r1,|L2.380|
000056  6048              STR      r0,[r1,#4]
;;;35         SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_DISABLE); // 100：关闭JTAG-DP，关闭SW-DP；
000058  4608              MOV      r0,r1
00005a  6840              LDR      r0,[r0,#4]
00005c  f0406080          ORR      r0,r0,#0x4000000
000060  6048              STR      r0,[r1,#4]
;;;36     
;;;37         // 010：两个等待状态，当 48MHz < SYSCLK ≤ 72MHz
;;;38         MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_1);
000062  4847              LDR      r0,|L2.384|
000064  6800              LDR      r0,[r0,#0]
000066  f0200007          BIC      r0,r0,#7
00006a  1c80              ADDS     r0,r0,#2
00006c  4944              LDR      r1,|L2.384|
00006e  6008              STR      r0,[r1,#0]
;;;39         if((uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY)) != FLASH_ACR_LATENCY_1) {
000070  4608              MOV      r0,r1
000072  6800              LDR      r0,[r0,#0]
000074  f0000007          AND      r0,r0,#7
000078  2802              CMP      r0,#2
00007a  d001              BEQ      |L2.128|
;;;40             Error_Handle();  
00007c  f7fffffe          BL       Error_Handle
                  |L2.128|
;;;41         }
;;;42     
;;;43         // 外部高速时钟使能
;;;44         // 1： HSE振荡器开启
;;;45         SET_BIT(RCC->CR, RCC_CR_HSEON);
000080  483b              LDR      r0,|L2.368|
000082  6800              LDR      r0,[r0,#0]
000084  f4403080          ORR      r0,r0,#0x10000
000088  4939              LDR      r1,|L2.368|
00008a  6008              STR      r0,[r1,#0]
;;;46         while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RCC_CR_HSERDY);
00008c  bf00              NOP      
                  |L2.142|
00008e  4838              LDR      r0,|L2.368|
000090  6800              LDR      r0,[r0,#0]
000092  f4003000          AND      r0,r0,#0x20000
000096  f5b03f00          CMP      r0,#0x20000
00009a  d1f8              BNE      |L2.142|
;;;47     
;;;48         // PLL输入时钟源  1： PREDIV1输出作为PLL输入时钟
;;;49         // PREDIV1分频因子的低位  置0
;;;50         // PLL倍频系数  0111： PLL 9倍频输出
;;;51         MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
00009c  4834              LDR      r0,|L2.368|
00009e  6840              LDR      r0,[r0,#4]
0000a0  f420107c          BIC      r0,r0,#0x3f0000
0000a4  f44010e8          ORR      r0,r0,#0x1d0000
0000a8  4931              LDR      r1,|L2.368|
0000aa  6048              STR      r0,[r1,#4]
;;;52                  (RCC_CFGR_PLLSRC & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | RCC_CFGR_PLLMULL9);
;;;53     
;;;54         // 1： PLL使能。
;;;55         SET_BIT(RCC->CR, RCC_CR_PLLON);
0000ac  4608              MOV      r0,r1
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f0407080          ORR      r0,r0,#0x1000000
0000b4  6008              STR      r0,[r1,#0]
;;;56         while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RCC_CR_PLLRDY);
0000b6  bf00              NOP      
                  |L2.184|
0000b8  482d              LDR      r0,|L2.368|
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0007000          AND      r0,r0,#0x2000000
0000c0  f1b07f00          CMP      r0,#0x2000000
0000c4  d1f8              BNE      |L2.184|
;;;57     
;;;58         // AHB预分频  0xxx： SYSCLK不分频
;;;59         MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
0000c6  482a              LDR      r0,|L2.368|
0000c8  6840              LDR      r0,[r0,#4]
0000ca  f02000f0          BIC      r0,r0,#0xf0
0000ce  4928              LDR      r1,|L2.368|
0000d0  6048              STR      r0,[r1,#4]
;;;60         // 低速APB预分频   100： HCLK 2分频
;;;61         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
0000d2  4608              MOV      r0,r1
0000d4  6840              LDR      r0,[r0,#4]
0000d6  f42060e0          BIC      r0,r0,#0x700
0000da  f4406080          ORR      r0,r0,#0x400
0000de  6048              STR      r0,[r1,#4]
;;;62         // 高速APB预分频   0xx： HCLK不分频
;;;63         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
0000e0  4608              MOV      r0,r1
0000e2  6840              LDR      r0,[r0,#4]
0000e4  f4205060          BIC      r0,r0,#0x3800
0000e8  6048              STR      r0,[r1,#4]
;;;64         // 系统时钟切换    10： PLL输出作为系统时钟；
;;;65         MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
0000ea  4608              MOV      r0,r1
0000ec  6840              LDR      r0,[r0,#4]
0000ee  f0200003          BIC      r0,r0,#3
0000f2  1c80              ADDS     r0,r0,#2
0000f4  6048              STR      r0,[r1,#4]
;;;66         while((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS)) != RCC_CFGR_SWS_PLL);
0000f6  bf00              NOP      
                  |L2.248|
0000f8  481d              LDR      r0,|L2.368|
0000fa  6840              LDR      r0,[r0,#4]
0000fc  f000000c          AND      r0,r0,#0xc
000100  2808              CMP      r0,#8
000102  d1f9              BNE      |L2.248|
;;;67     
;;;68     
;;;69         SysTick->LOAD  = (uint32_t)((72000000 / 1000U) - 1UL);  // 倒数到0， 重新装载
000104  481f              LDR      r0,|L2.388|
000106  f04f21e0          MOV      r1,#0xe000e000
00010a  6148              STR      r0,[r1,#0x14]
;;;70         SysTick->VAL   = 0UL;   // current值  写入清0
00010c  2000              MOVS     r0,#0
00010e  6188              STR      r0,[r1,#0x18]
;;;71         SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |      // 1 : 内核时钟源 FCLK
000110  2005              MOVS     r0,#5
000112  6108              STR      r0,[r1,#0x10]
;;;72                         SysTick_CTRL_ENABLE_Msk;  // 定时器使能
;;;73     
;;;74     
;;;75         SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
000114  4608              MOV      r0,r1
000116  6900              LDR      r0,[r0,#0x10]
000118  f0400004          ORR      r0,r0,#4
00011c  6108              STR      r0,[r1,#0x10]
;;;76         SystemCoreClock = 72000000;
00011e  481a              LDR      r0,|L2.392|
000120  491a              LDR      r1,|L2.396|
000122  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;77     
;;;78         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);
000124  4812              LDR      r0,|L2.368|
000126  6980              LDR      r0,[r0,#0x18]
000128  f0400004          ORR      r0,r0,#4
00012c  4910              LDR      r1,|L2.368|
00012e  6188              STR      r0,[r1,#0x18]
;;;79         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN);
000130  4608              MOV      r0,r1
000132  6980              LDR      r0,[r0,#0x18]
000134  f0400008          ORR      r0,r0,#8
000138  6188              STR      r0,[r1,#0x18]
;;;80         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN);
00013a  4608              MOV      r0,r1
00013c  6980              LDR      r0,[r0,#0x18]
00013e  f0400010          ORR      r0,r0,#0x10
000142  6188              STR      r0,[r1,#0x18]
;;;81         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPDEN);
000144  4608              MOV      r0,r1
000146  6980              LDR      r0,[r0,#0x18]
000148  f0400020          ORR      r0,r0,#0x20
00014c  6188              STR      r0,[r1,#0x18]
;;;82         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);
00014e  4608              MOV      r0,r1
000150  6980              LDR      r0,[r0,#0x18]
000152  f4404080          ORR      r0,r0,#0x4000
000156  6188              STR      r0,[r1,#0x18]
;;;83         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);
000158  4608              MOV      r0,r1
00015a  6980              LDR      r0,[r0,#0x18]
00015c  f4405080          ORR      r0,r0,#0x1000
000160  6188              STR      r0,[r1,#0x18]
;;;84         SET_BIT(RCC->AHBENR,  RCC_AHBENR_SDIOEN);
000162  4608              MOV      r0,r1
000164  6940              LDR      r0,[r0,#0x14]
000166  f4406080          ORR      r0,r0,#0x400
00016a  6148              STR      r0,[r1,#0x14]
;;;85     }
00016c  bd08              POP      {r3,pc}
;;;86     
                          ENDP

00016e  0000              DCW      0x0000
                  |L2.368|
                          DCD      0x40021000
                  |L2.372|
                          DCD      0xe000ed0c
                  |L2.376|
                          DCD      0x05fa0000
                  |L2.380|
                          DCD      0x40010000
                  |L2.384|
                          DCD      0x40022000
                  |L2.388|
                          DCD      0x0001193f
                  |L2.392|
                          DCD      0x044aa200
                  |L2.396|
                          DCD      SystemCoreClock

                          AREA ||i.delay||, CODE, READONLY, ALIGN=2

                  delay PROC
;;;86     
;;;87     void delay(uint32_t val)
000000  4601              MOV      r1,r0
;;;88     {
;;;89         int i;
;;;90         for (i = 0; i < 3600000; ++i);
000002  2000              MOVS     r0,#0
000004  e000              B        |L3.8|
                  |L3.6|
000006  1c40              ADDS     r0,r0,#1
                  |L3.8|
000008  4a01              LDR      r2,|L3.16|
00000a  4290              CMP      r0,r2
00000c  dbfb              BLT      |L3.6|
;;;91     }
00000e  4770              BX       lr
;;;92     
                          ENDP

                  |L3.16|
                          DCD      0x0036ee80

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;92     
;;;93     int main()
000000  b508              PUSH     {r3,lr}
;;;94     {
;;;95         uint8_t buf = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;96     
;;;97         RCC_Init();
000006  f7fffffe          BL       RCC_Init
;;;98         GPIO_Init();
00000a  f7fffffe          BL       GPIO_Init
;;;99         USART_Init();
00000e  f7fffffe          BL       USART_Init
;;;100        SPI_Init();
000012  f7fffffe          BL       SPI_Init
;;;101        SDIOEx_Init();
000016  f7fffffe          BL       SDIOEx_Init
;;;102        EEPROM_Init();
00001a  f7fffffe          BL       EEPROM_Init
;;;103    
;;;104        uartprintf("STM32 bootloader V1.0\r\n");
00001e  a015              ADR      r0,|L4.116|
000020  f7fffffe          BL       uartprintf
;;;105    
;;;106        BootargsInit();
000024  f7fffffe          BL       BootargsInit
;;;107        if (GetBootargFromEEP() == STM32_FALSE) {
000028  f7fffffe          BL       GetBootargFromEEP
00002c  b928              CBNZ     r0,|L4.58|
;;;108            uartprintf("Could not find bootargs, using default\r\n");
00002e  a017              ADR      r0,|L4.140|
000030  f7fffffe          BL       uartprintf
;;;109            GetBootargFromDefault();
000034  f7fffffe          BL       GetBootargFromDefault
000038  e009              B        |L4.78|
                  |L4.58|
;;;110        } else {
;;;111            uartprintf("Press any key to stop auto start in : ");
00003a  a01f              ADR      r0,|L4.184|
00003c  f7fffffe          BL       uartprintf
;;;112            if (autoboot() == STM32_SUCCESS) {
000040  f7fffffe          BL       autoboot
000044  2801              CMP      r0,#1
000046  d102              BNE      |L4.78|
;;;113                bootm(&buf);
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       bootm
                  |L4.78|
;;;114            }
;;;115        }
;;;116    
;;;117        uartprintf("stm32 > ");
00004e  a024              ADR      r0,|L4.224|
000050  f7fffffe          BL       uartprintf
;;;118    
;;;119        while(1) {
000054  e00d              B        |L4.114|
                  |L4.86|
;;;120            if((USART1->SR & USART_CR1_RXNEIE) != 0) {
000056  4825              LDR      r0,|L4.236|
000058  6800              LDR      r0,[r0,#0]
00005a  f0000020          AND      r0,r0,#0x20
00005e  b140              CBZ      r0,|L4.114|
;;;121                buf = USART1->DR;
000060  4822              LDR      r0,|L4.236|
000062  1d00              ADDS     r0,r0,#4
000064  6800              LDR      r0,[r0,#0]
000066  b2c0              UXTB     r0,r0
000068  9000              STR      r0,[sp,#0]
;;;122                USART_RxProcess(buf);
00006a  f89d0000          LDRB     r0,[sp,#0]
00006e  f7fffffe          BL       USART_RxProcess
                  |L4.114|
000072  e7f0              B        |L4.86|
;;;123            }
;;;124        }
;;;125    }
                          ENDP

                  |L4.116|
000074  53544d33          DCB      "STM32 bootloader V1.0\r\n",0
000078  3220626f
00007c  6f746c6f
000080  61646572
000084  2056312e
000088  300d0a00
                  |L4.140|
00008c  436f756c          DCB      "Could not find bootargs, using default\r\n",0
000090  64206e6f
000094  74206669
000098  6e642062
00009c  6f6f7461
0000a0  7267732c
0000a4  20757369
0000a8  6e672064
0000ac  65666175
0000b0  6c740d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L4.184|
0000b8  50726573          DCB      "Press any key to stop auto start in : ",0
0000bc  7320616e
0000c0  79206b65
0000c4  7920746f
0000c8  2073746f
0000cc  70206175
0000d0  746f2073
0000d4  74617274
0000d8  20696e20
0000dc  3a2000  
0000df  00                DCB      0
                  |L4.224|
0000e0  73746d33          DCB      "stm32 > ",0
0000e4  32203e20
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L4.236|
                          DCD      0x40013800

;*** Start embedded assembler ***

#line 1 "Core\\Src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_183b7d92____REV16|
#line 388 ".\\Core\\Inc\\cmsis_armcc.h"
|__asm___6_main_c_183b7d92____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_183b7d92____REVSH|
#line 402
|__asm___6_main_c_183b7d92____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_183b7d92____RRX|
#line 587
|__asm___6_main_c_183b7d92____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
