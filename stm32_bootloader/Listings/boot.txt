; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\boot.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\boot.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Core\Inc -IC:\workspace\stm32_bootloader\RTE\_stm32iap -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F103xE --omf_browse=.\objects\boot.crf Core\Src\boot.c]
                          THUMB

                          AREA ||i.AppJump||, CODE, READONLY, ALIGN=2

                  AppJump PROC
;;;379    
;;;380    void AppJump()
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382    	  uartprintf("BootAddrData %d\r\n", *(__IO uint32_t *) APP_DEFAULT_ADD);
000002  480e              LDR      r0,|L1.60|
000004  6801              LDR      r1,[r0,#0]
000006  a00e              ADR      r0,|L1.64|
000008  f7fffffe          BL       uartprintf
;;;383        if (((*(__IO uint32_t *) APP_DEFAULT_ADD) & 0x2FFE0000) == 0x20000000) {
00000c  480b              LDR      r0,|L1.60|
00000e  6800              LDR      r0,[r0,#0]
000010  4910              LDR      r1,|L1.84|
000012  4008              ANDS     r0,r0,r1
000014  f1b05f00          CMP      r0,#0x20000000
000018  d10f              BNE      |L1.58|
;;;384            /* Jump to user application */
;;;385            JumpAddress = *(__IO uint32_t *) (APP_DEFAULT_ADD + 4);
00001a  4808              LDR      r0,|L1.60|
00001c  6840              LDR      r0,[r0,#4]
00001e  490e              LDR      r1,|L1.88|
000020  6008              STR      r0,[r1,#0]  ; JumpAddress
;;;386            JumpToApplication = (pFunction) JumpAddress;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; JumpAddress
000026  490d              LDR      r1,|L1.92|
000028  6008              STR      r0,[r1,#0]  ; JumpToApplication
;;;387    
;;;388            /* Initialize user application's Stack Pointer */
;;;389            __set_MSP(*(__IO uint32_t *) APP_DEFAULT_ADD);
00002a  4904              LDR      r1,|L1.60|
00002c  6808              LDR      r0,[r1,#0]
00002e  f3808808          MSR      MSP,r0
000032  bf00              NOP      
;;;390            JumpToApplication();
000034  4809              LDR      r0,|L1.92|
000036  6800              LDR      r0,[r0,#0]  ; JumpToApplication
000038  4780              BLX      r0
                  |L1.58|
;;;391        }
;;;392    }
00003a  bd10              POP      {r4,pc}
                          ENDP

                  |L1.60|
                          DCD      0x08005000
                  |L1.64|
000040  426f6f74          DCB      "BootAddrData %d\r\n",0
000044  41646472
000048  44617461
00004c  2025640d
000050  0a00    
000052  00                DCB      0
000053  00                DCB      0
                  |L1.84|
                          DCD      0x2ffe0000
                  |L1.88|
                          DCD      JumpAddress
                  |L1.92|
                          DCD      JumpToApplication

                          AREA ||i.BootargsInit||, CODE, READONLY, ALIGN=2

                  BootargsInit PROC
;;;264    //==================================================================================
;;;265    void BootargsInit()
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267        memset(&Bootargs, 0, sizeof(Bootargs_t));
000002  2120              MOVS     r1,#0x20
000004  4801              LDR      r0,|L2.12|
000006  f7fffffe          BL       __aeabi_memclr4
;;;268    }
00000a  bd10              POP      {r4,pc}
;;;269    
                          ENDP

                  |L2.12|
                          DCD      Bootargs

                          AREA ||i.GetBootargFromDefault||, CODE, READONLY, ALIGN=2

                  GetBootargFromDefault PROC
;;;297    
;;;298    void GetBootargFromDefault()
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300        Bootargs.header = BOOTARGS_HEADER;
000002  f2444055          MOV      r0,#0x4455
000006  4909              LDR      r1,|L3.44|
000008  8008              STRH     r0,[r1,#0]
;;;301        Bootargs.tail = BOOTARGS_TAIL;
00000a  f2455066          MOV      r0,#0x5566
00000e  8388              STRH     r0,[r1,#0x1c]
;;;302    
;;;303        Bootargs.version = 0;
000010  2000              MOVS     r0,#0
000012  6188              STR      r0,[r1,#0x18]  ; Bootargs
;;;304        strcpy((char *)Bootargs.confSrc, "NULL");
000014  a106              ADR      r1,|L3.48|
000016  4805              LDR      r0,|L3.44|
000018  1c80              ADDS     r0,r0,#2
00001a  f7fffffe          BL       strcpy
;;;305        strcpy((char *)Bootargs.statSrc, "NULL");
00001e  a104              ADR      r1,|L3.48|
000020  4802              LDR      r0,|L3.44|
000022  300c              ADDS     r0,r0,#0xc
000024  f7fffffe          BL       strcpy
;;;306    }
000028  bd10              POP      {r4,pc}
;;;307    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      Bootargs
                  |L3.48|
000030  4e554c4c          DCB      "NULL",0
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.GetBootargFromEEP||, CODE, READONLY, ALIGN=2

                  GetBootargFromEEP PROC
;;;307    
;;;308    BootState_t GetBootargFromEEP()
000000  b510              PUSH     {r4,lr}
;;;309    {
;;;310        EEPROM_Read(BOOTARGS_ADDR, (uint8_t *) &Bootargs, sizeof(Bootargs_t));
000002  2220              MOVS     r2,#0x20
000004  490a              LDR      r1,|L4.48|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       EEPROM_Read
;;;311    
;;;312        if ((BOOTARGS_HEADER == Bootargs.header) &&
00000c  4808              LDR      r0,|L4.48|
00000e  8800              LDRH     r0,[r0,#0]  ; Bootargs
000010  f2444155          MOV      r1,#0x4455
000014  4288              CMP      r0,r1
000016  d107              BNE      |L4.40|
;;;313            (BOOTARGS_TAIL == Bootargs.tail)) {
000018  4805              LDR      r0,|L4.48|
00001a  8b80              LDRH     r0,[r0,#0x1c]  ; Bootargs
00001c  f2455166          MOV      r1,#0x5566
000020  4288              CMP      r0,r1
000022  d101              BNE      |L4.40|
;;;314            return STM32_SUCCESS;
000024  2001              MOVS     r0,#1
                  |L4.38|
;;;315        } else {
;;;316            BootargsInit();
;;;317            return STM32_FALSE;
;;;318        }
;;;319    }
000026  bd10              POP      {r4,pc}
                  |L4.40|
000028  f7fffffe          BL       BootargsInit
00002c  2000              MOVS     r0,#0                 ;317
00002e  e7fa              B        |L4.38|
;;;320    
                          ENDP

                  |L4.48|
                          DCD      Bootargs

                          AREA ||i.GetImageInfo||, CODE, READONLY, ALIGN=2

                  GetImageInfo PROC
;;;119    
;;;120    static BootState_t GetImageInfo(Imageargs_t *iargs, uint8_t *src)
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;122        if (NULL == iargs)
000006  b90c              CBNZ     r4,|L5.12|
;;;123            return STM32_FALSE;
000008  2000              MOVS     r0,#0
                  |L5.10|
;;;124    
;;;125        memset(iargs, 0, sizeof(Imageargs_t));
;;;126        if (strcmp((char *)src, "EEPROM") == 0) { // read version from eeprom
;;;127            EEPROM_Read(IMAGE_EEP_ARGS_ADDR, (uint8_t *) iargs, sizeof(Imageargs_t));
;;;128            if ((IMAGEARGS_HEADER == iargs->header) &&
;;;129                (IMAGEARGS_TAIL == iargs->tail)) {
;;;130                return STM32_SUCCESS;
;;;131            } else {
;;;132                return STM32_FALSE;
;;;133            }
;;;134        } else { // read version from sd card
;;;135            memset(ImageBuf, 0, IMAGE_BUFFER_SIZE);
;;;136            if (SD_ReadBlock((uint32_t *)ImageBuf, IMAGE_SDCARD_ARGS_ADDR, IMAGE_BUFFER_SIZE) == SD_OK) {
;;;137      					memcpy(iargs, ImageBuf, sizeof(Imageargs_t));
;;;138    
;;;139                if ((IMAGEARGS_HEADER == iargs->header) &&
;;;140                    (IMAGEARGS_TAIL == iargs->tail)) {
;;;141                    return STM32_SUCCESS;
;;;142                } else {
;;;143                    return STM32_FALSE;
;;;144                }
;;;145            } else {
;;;146    					  uartprintf("Read SD Block fail\r\n");
;;;147                return STM32_FALSE;
;;;148            }
;;;149        }
;;;150    }
00000a  bd70              POP      {r4-r6,pc}
                  |L5.12|
00000c  2000              MOVS     r0,#0                 ;125
00000e  6020              STR      r0,[r4,#0]            ;125
000010  6060              STR      r0,[r4,#4]            ;125
000012  60a0              STR      r0,[r4,#8]            ;125
000014  a11e              ADR      r1,|L5.144|
000016  4628              MOV      r0,r5                 ;126
000018  f7fffffe          BL       strcmp
00001c  b998              CBNZ     r0,|L5.70|
00001e  220c              MOVS     r2,#0xc               ;127
000020  4621              MOV      r1,r4                 ;127
000022  f44f5080          MOV      r0,#0x1000            ;127
000026  f7fffffe          BL       EEPROM_Read
00002a  8820              LDRH     r0,[r4,#0]            ;128
00002c  f2422133          MOV      r1,#0x2233            ;128
000030  4288              CMP      r0,r1                 ;128
000032  d106              BNE      |L5.66|
000034  8920              LDRH     r0,[r4,#8]            ;129
000036  f6480199          MOV      r1,#0x8899            ;129
00003a  4288              CMP      r0,r1                 ;129
00003c  d101              BNE      |L5.66|
00003e  2001              MOVS     r0,#1                 ;130
000040  e7e3              B        |L5.10|
                  |L5.66|
000042  2000              MOVS     r0,#0                 ;132
000044  e7e1              B        |L5.10|
                  |L5.70|
000046  f44f7100          MOV      r1,#0x200             ;135
00004a  4813              LDR      r0,|L5.152|
00004c  f7fffffe          BL       __aeabi_memclr4
000050  f44f7200          MOV      r2,#0x200             ;136
000054  2100              MOVS     r1,#0                 ;136
000056  4810              LDR      r0,|L5.152|
000058  f7fffffe          BL       SD_ReadBlock
00005c  282a              CMP      r0,#0x2a              ;136
00005e  d111              BNE      |L5.132|
000060  4a0d              LDR      r2,|L5.152|
000062  ca07              LDM      r2,{r0-r2}            ;137
000064  e8840007          STM      r4,{r0-r2}            ;137
000068  8820              LDRH     r0,[r4,#0]            ;139
00006a  f2422133          MOV      r1,#0x2233            ;139
00006e  4288              CMP      r0,r1                 ;139
000070  d106              BNE      |L5.128|
000072  8920              LDRH     r0,[r4,#8]            ;140
000074  f6480199          MOV      r1,#0x8899            ;140
000078  4288              CMP      r0,r1                 ;140
00007a  d101              BNE      |L5.128|
00007c  2001              MOVS     r0,#1                 ;141
00007e  e7c4              B        |L5.10|
                  |L5.128|
000080  2000              MOVS     r0,#0                 ;143
000082  e7c2              B        |L5.10|
                  |L5.132|
000084  a005              ADR      r0,|L5.156|
000086  f7fffffe          BL       uartprintf
00008a  2000              MOVS     r0,#0                 ;147
00008c  e7bd              B        |L5.10|
;;;151    
                          ENDP

00008e  0000              DCW      0x0000
                  |L5.144|
000090  45455052          DCB      "EEPROM",0
000094  4f4d00  
000097  00                DCB      0
                  |L5.152|
                          DCD      ImageBuf
                  |L5.156|
00009c  52656164          DCB      "Read SD Block fail\r\n",0
0000a0  20534420
0000a4  426c6f63
0000a8  6b206661
0000ac  696c0d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.ImageCopyEepToFlash||, CODE, READONLY, ALIGN=2

                  ImageCopyEepToFlash PROC
;;;151    
;;;152    static void ImageCopyEepToFlash()
000000  b5fe              PUSH     {r1-r7,lr}
;;;153    {
;;;154        Imageargs_t iargs;
;;;155        uint32_t eepAddr = IMAGE_EEPROM_ADDR;
000002  f44f5600          MOV      r6,#0x2000
;;;156        uint32_t flashAddr = APP_DEFAULT_ADD;
000006  4d1b              LDR      r5,|L6.116|
;;;157        uint32_t size;
;;;158    
;;;159    	  uartprintf("\r\nCopying Image from EEPROM to Flash ...\r\n");
000008  a01b              ADR      r0,|L6.120|
00000a  f7fffffe          BL       uartprintf
;;;160        if (GetImageInfo(&iargs, "EEPROM") == STM32_SUCCESS) {
00000e  a125              ADR      r1,|L6.164|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       GetImageInfo
000016  2801              CMP      r0,#1
000018  d127              BNE      |L6.106|
;;;161            size = iargs.size;
00001a  9c01              LDR      r4,[sp,#4]
;;;162    
;;;163            while (size > 0) {
00001c  e022              B        |L6.100|
                  |L6.30|
;;;164                if ((flashAddr % FLASH_PAGE_SIZE) == 0) {
00001e  f3c5000a          UBFX     r0,r5,#0,#11
000022  b910              CBNZ     r0,|L6.42|
;;;165                    FLASH_Erase(flashAddr);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       FLASH_Erase
                  |L6.42|
;;;166                }
;;;167    
;;;168                memset(ImageBuf, 0xff, IMAGE_BUFFER_SIZE);
00002a  22ff              MOVS     r2,#0xff
00002c  f44f7100          MOV      r1,#0x200
000030  481e              LDR      r0,|L6.172|
000032  f7fffffe          BL       __aeabi_memset
;;;169                EEPROM_Read(eepAddr, ImageBuf, IMAGE_BUFFER_SIZE);
000036  f44f7200          MOV      r2,#0x200
00003a  491c              LDR      r1,|L6.172|
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       EEPROM_Read
;;;170                FLASH_Program((uint8_t *)flashAddr, ImageBuf, IMAGE_BUFFER_SIZE);
000042  f44f7200          MOV      r2,#0x200
000046  4919              LDR      r1,|L6.172|
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       FLASH_Program
;;;171    
;;;172                eepAddr += IMAGE_BUFFER_SIZE;
00004e  f5067600          ADD      r6,r6,#0x200
;;;173                flashAddr += IMAGE_BUFFER_SIZE;
000052  f5057500          ADD      r5,r5,#0x200
;;;174    
;;;175                if (size < IMAGE_BUFFER_SIZE) {
000056  f5b47f00          CMP      r4,#0x200
00005a  d201              BCS      |L6.96|
;;;176                    size = 0;
00005c  2400              MOVS     r4,#0
00005e  e001              B        |L6.100|
                  |L6.96|
;;;177                } else {
;;;178                    size -= IMAGE_BUFFER_SIZE;
000060  f5a47400          SUB      r4,r4,#0x200
                  |L6.100|
000064  2c00              CMP      r4,#0                 ;163
000066  d1da              BNE      |L6.30|
000068  e002              B        |L6.112|
                  |L6.106|
;;;179                }
;;;180            }
;;;181        } else {
;;;182            uartprintf("Could not find valid image at EEPROM\r\n");
00006a  a011              ADR      r0,|L6.176|
00006c  f7fffffe          BL       uartprintf
                  |L6.112|
;;;183        }
;;;184        return;
;;;185    }
000070  bdfe              POP      {r1-r7,pc}
;;;186    
                          ENDP

000072  0000              DCW      0x0000
                  |L6.116|
                          DCD      0x08005000
                  |L6.120|
000078  0d0a436f          DCB      "\r\nCopying Image from EEPROM to Flash ...\r\n",0
00007c  7079696e
000080  6720496d
000084  61676520
000088  66726f6d
00008c  20454550
000090  524f4d20
000094  746f2046
000098  6c617368
00009c  202e2e2e
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L6.164|
0000a4  45455052          DCB      "EEPROM",0
0000a8  4f4d00  
0000ab  00                DCB      0
                  |L6.172|
                          DCD      ImageBuf
                  |L6.176|
0000b0  436f756c          DCB      "Could not find valid image at EEPROM\r\n",0
0000b4  64206e6f
0000b8  74206669
0000bc  6e642076
0000c0  616c6964
0000c4  20696d61
0000c8  67652061
0000cc  74204545
0000d0  50524f4d
0000d4  0d0a00  
0000d7  00                DCB      0

                          AREA ||i.ImageCopySdToEep||, CODE, READONLY, ALIGN=2

                  ImageCopySdToEep PROC
;;;223    
;;;224    static void ImageCopySdToEep()
000000  b5fe              PUSH     {r1-r7,lr}
;;;225    {
;;;226        Imageargs_t iargs;
;;;227        uint32_t sdAddr = IMAGE_SDCARD_ADDR;
000002  f44f7600          MOV      r6,#0x200
;;;228        uint32_t eepAddr = IMAGE_EEPROM_ADDR;
000006  0135              LSLS     r5,r6,#4
;;;229        uint32_t size;
;;;230    	
;;;231    	  uartprintf("\r\nCopying Image from SD to EEPROM ...\r\n");
000008  a01e              ADR      r0,|L7.132|
00000a  f7fffffe          BL       uartprintf
;;;232        if (GetImageInfo(&iargs, "SD") == STM32_SUCCESS) {
00000e  a127              ADR      r1,|L7.172|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       GetImageInfo
000016  2801              CMP      r0,#1
000018  d12f              BNE      |L7.122|
;;;233            EEProm_SectorErrase(IMAGE_EEP_ARGS_ADDR);
00001a  0300              LSLS     r0,r0,#12
00001c  f7fffffe          BL       EEProm_SectorErrase
;;;234            EEPROM_Write(IMAGE_EEP_ARGS_ADDR, (uint8_t *) &iargs, sizeof(Imageargs_t));
000020  220c              MOVS     r2,#0xc
000022  4669              MOV      r1,sp
000024  1068              ASRS     r0,r5,#1
000026  f7fffffe          BL       EEPROM_Write
;;;235    
;;;236            size = iargs.size;
00002a  9c01              LDR      r4,[sp,#4]
;;;237    
;;;238            while (size > 0) {
00002c  e022              B        |L7.116|
                  |L7.46|
;;;239                if ((eepAddr % EEPROM_PAGE_SIZE) == 0) {
00002e  f3c5000b          UBFX     r0,r5,#0,#12
000032  b910              CBNZ     r0,|L7.58|
;;;240                    EEProm_SectorErrase(eepAddr);
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       EEProm_SectorErrase
                  |L7.58|
;;;241                }
;;;242    
;;;243                memset(ImageBuf, 0xff, IMAGE_BUFFER_SIZE);
00003a  22ff              MOVS     r2,#0xff
00003c  f44f7100          MOV      r1,#0x200
000040  481b              LDR      r0,|L7.176|
000042  f7fffffe          BL       __aeabi_memset
;;;244                SD_ReadBlock((uint32_t *)ImageBuf, sdAddr, IMAGE_BUFFER_SIZE);
000046  f44f7200          MOV      r2,#0x200
00004a  4631              MOV      r1,r6
00004c  4818              LDR      r0,|L7.176|
00004e  f7fffffe          BL       SD_ReadBlock
;;;245                EEPROM_Write(eepAddr, (uint8_t *) ImageBuf, IMAGE_BUFFER_SIZE);
000052  f44f7200          MOV      r2,#0x200
000056  4916              LDR      r1,|L7.176|
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       EEPROM_Write
;;;246    
;;;247                sdAddr += IMAGE_BUFFER_SIZE;
00005e  f5067600          ADD      r6,r6,#0x200
;;;248                eepAddr += IMAGE_BUFFER_SIZE;
000062  f5057500          ADD      r5,r5,#0x200
;;;249    
;;;250                if (size < IMAGE_BUFFER_SIZE) {
000066  f5b47f00          CMP      r4,#0x200
00006a  d201              BCS      |L7.112|
;;;251                    size = 0;
00006c  2400              MOVS     r4,#0
00006e  e001              B        |L7.116|
                  |L7.112|
;;;252                } else {
;;;253                    size -= IMAGE_BUFFER_SIZE;
000070  f5a47400          SUB      r4,r4,#0x200
                  |L7.116|
000074  2c00              CMP      r4,#0                 ;238
000076  d1da              BNE      |L7.46|
000078  e002              B        |L7.128|
                  |L7.122|
;;;254                }
;;;255            }
;;;256        } else {
;;;257            uartprintf("Could not find valid image at SD\r\n");
00007a  a00e              ADR      r0,|L7.180|
00007c  f7fffffe          BL       uartprintf
                  |L7.128|
;;;258        }
;;;259        return;
;;;260    }
000080  bdfe              POP      {r1-r7,pc}
;;;261    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
000084  0d0a436f          DCB      "\r\nCopying Image from SD to EEPROM ...\r\n",0
000088  7079696e
00008c  6720496d
000090  61676520
000094  66726f6d
000098  20534420
00009c  746f2045
0000a0  4550524f
0000a4  4d202e2e
0000a8  2e0d0a00
                  |L7.172|
0000ac  534400            DCB      "SD",0
0000af  00                DCB      0
                  |L7.176|
                          DCD      ImageBuf
                  |L7.180|
0000b4  436f756c          DCB      "Could not find valid image at SD\r\n",0
0000b8  64206e6f
0000bc  74206669
0000c0  6e642076
0000c4  616c6964
0000c8  20696d61
0000cc  67652061
0000d0  74205344
0000d4  0d0a00  
0000d7  00                DCB      0

                          AREA ||i.ImageCopySdToFlash||, CODE, READONLY, ALIGN=2

                  ImageCopySdToFlash PROC
;;;186    
;;;187    static void ImageCopySdToFlash()
000000  b5fe              PUSH     {r1-r7,lr}
;;;188    {
;;;189        Imageargs_t iargs;
;;;190        uint32_t sdAddr = IMAGE_SDCARD_ADDR;
000002  f44f7600          MOV      r6,#0x200
;;;191        uint32_t flashAddr = APP_DEFAULT_ADD;
000006  4d1d              LDR      r5,|L8.124|
;;;192        uint32_t size;
;;;193    
;;;194    	  uartprintf("\r\nCopying Image from SD to Flash ...\r\n");
000008  a01d              ADR      r0,|L8.128|
00000a  f7fffffe          BL       uartprintf
;;;195    	  FLASH_Unlock();
00000e  f7fffffe          BL       FLASH_Unlock
;;;196        if (GetImageInfo(&iargs, "SD") == STM32_SUCCESS) {
000012  a125              ADR      r1,|L8.168|
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       GetImageInfo
00001a  2801              CMP      r0,#1
00001c  d127              BNE      |L8.110|
;;;197            size = iargs.size;
00001e  9c01              LDR      r4,[sp,#4]
;;;198    
;;;199            while (size > 0) {
000020  e022              B        |L8.104|
                  |L8.34|
;;;200                if ((flashAddr % FLASH_PAGE_SIZE) == 0) {
000022  f3c5000a          UBFX     r0,r5,#0,#11
000026  b910              CBNZ     r0,|L8.46|
;;;201                    FLASH_Erase(flashAddr);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       FLASH_Erase
                  |L8.46|
;;;202                }
;;;203    
;;;204                memset(ImageBuf, 0xff, IMAGE_BUFFER_SIZE);
00002e  22ff              MOVS     r2,#0xff
000030  f44f7100          MOV      r1,#0x200
000034  481d              LDR      r0,|L8.172|
000036  f7fffffe          BL       __aeabi_memset
;;;205                SD_ReadBlock((uint32_t *)ImageBuf, sdAddr, IMAGE_BUFFER_SIZE);
00003a  f44f7200          MOV      r2,#0x200
00003e  4631              MOV      r1,r6
000040  481a              LDR      r0,|L8.172|
000042  f7fffffe          BL       SD_ReadBlock
;;;206                FLASH_Program((uint8_t *)flashAddr, ImageBuf, IMAGE_BUFFER_SIZE);
000046  f44f7200          MOV      r2,#0x200
00004a  4918              LDR      r1,|L8.172|
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       FLASH_Program
;;;207    
;;;208                sdAddr += IMAGE_BUFFER_SIZE;
000052  f5067600          ADD      r6,r6,#0x200
;;;209                flashAddr += IMAGE_BUFFER_SIZE;
000056  f5057500          ADD      r5,r5,#0x200
;;;210    
;;;211                if (size < IMAGE_BUFFER_SIZE) {
00005a  f5b47f00          CMP      r4,#0x200
00005e  d201              BCS      |L8.100|
;;;212                    size = 0;
000060  2400              MOVS     r4,#0
000062  e001              B        |L8.104|
                  |L8.100|
;;;213                } else {
;;;214                    size -= IMAGE_BUFFER_SIZE;
000064  f5a47400          SUB      r4,r4,#0x200
                  |L8.104|
000068  2c00              CMP      r4,#0                 ;199
00006a  d1da              BNE      |L8.34|
00006c  e002              B        |L8.116|
                  |L8.110|
;;;215                }
;;;216            }
;;;217        } else {
;;;218            uartprintf("Could not find valid image at SD\r\n");
00006e  a010              ADR      r0,|L8.176|
000070  f7fffffe          BL       uartprintf
                  |L8.116|
;;;219        }
;;;220    		FLASH_Lock();
000074  f7fffffe          BL       FLASH_Lock
;;;221        return;
;;;222    }
000078  bdfe              POP      {r1-r7,pc}
;;;223    
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
                          DCD      0x08005000
                  |L8.128|
000080  0d0a436f          DCB      "\r\nCopying Image from SD to Flash ...\r\n",0
000084  7079696e
000088  6720496d
00008c  61676520
000090  66726f6d
000094  20534420
000098  746f2046
00009c  6c617368
0000a0  202e2e2e
0000a4  0d0a00  
0000a7  00                DCB      0
                  |L8.168|
0000a8  534400            DCB      "SD",0
0000ab  00                DCB      0
                  |L8.172|
                          DCD      ImageBuf
                  |L8.176|
0000b0  436f756c          DCB      "Could not find valid image at SD\r\n",0
0000b4  64206e6f
0000b8  74206669
0000bc  6e642076
0000c0  616c6964
0000c4  20696d61
0000c8  67652061
0000cc  74205344
0000d0  0d0a00  
0000d3  00                DCB      0

                          AREA ||i.autoboot||, CODE, READONLY, ALIGN=2

                  autoboot PROC
;;;270    #define autoboot_delay(x) do {for (x=0;x<72000;++x);} while(0)
;;;271    BootState_t autoboot()
000000  b5f8              PUSH     {r3-r7,lr}
;;;272    {
;;;273        uint8_t buf = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;274        uint8_t count = 6;
000006  2406              MOVS     r4,#6
;;;275        uint8_t i;
;;;276    	  uint32_t j;
;;;277    
;;;278        buf = count + 0x30;
000008  f1040030          ADD      r0,r4,#0x30
00000c  9000              STR      r0,[sp,#0]
;;;279        USART_SendData(&buf, 1);
00000e  2101              MOVS     r1,#1
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       USART_SendData
;;;280    
;;;281        while (count > 0) {
000016  e022              B        |L9.94|
                  |L9.24|
;;;282            for (i = 0; i < 100; ++i) {
000018  2500              MOVS     r5,#0
00001a  e018              B        |L9.78|
                  |L9.28|
;;;283                if((USART1->SR & USART_CR1_RXNEIE) != 0) {
00001c  4813              LDR      r0,|L9.108|
00001e  6800              LDR      r0,[r0,#0]
000020  f0000020          AND      r0,r0,#0x20
000024  b148              CBZ      r0,|L9.58|
;;;284                    buf = USART1->DR;
000026  4811              LDR      r0,|L9.108|
000028  1d00              ADDS     r0,r0,#4
00002a  6800              LDR      r0,[r0,#0]
00002c  b2c0              UXTB     r0,r0
00002e  9000              STR      r0,[sp,#0]
;;;285                    uartprintf("\r\n");
000030  a00f              ADR      r0,|L9.112|
000032  f7fffffe          BL       uartprintf
;;;286                    return STM32_FALSE;
000036  2000              MOVS     r0,#0
                  |L9.56|
;;;287                }
;;;288    						 autoboot_delay(j);
;;;289            }
;;;290    
;;;291            count--;
;;;292    				uartprintf("\b%d", count);
;;;293        }
;;;294        uartprintf("\r\n");
;;;295        return STM32_SUCCESS;
;;;296    }
000038  bdf8              POP      {r3-r7,pc}
                  |L9.58|
00003a  bf00              NOP                            ;288
00003c  2600              MOVS     r6,#0                 ;288
00003e  e000              B        |L9.66|
                  |L9.64|
000040  1c76              ADDS     r6,r6,#1              ;288
                  |L9.66|
000042  480c              LDR      r0,|L9.116|
000044  4286              CMP      r6,r0                 ;288
000046  d3fb              BCC      |L9.64|
000048  bf00              NOP                            ;288
00004a  1c68              ADDS     r0,r5,#1              ;282
00004c  b2c5              UXTB     r5,r0                 ;282
                  |L9.78|
00004e  2d64              CMP      r5,#0x64              ;282
000050  dbe4              BLT      |L9.28|
000052  1e60              SUBS     r0,r4,#1              ;291
000054  b2c4              UXTB     r4,r0                 ;291
000056  4621              MOV      r1,r4                 ;292
000058  a007              ADR      r0,|L9.120|
00005a  f7fffffe          BL       uartprintf
                  |L9.94|
00005e  2c00              CMP      r4,#0                 ;281
000060  dcda              BGT      |L9.24|
000062  a003              ADR      r0,|L9.112|
000064  f7fffffe          BL       uartprintf
000068  2001              MOVS     r0,#1                 ;295
00006a  e7e5              B        |L9.56|
;;;297    
                          ENDP

                  |L9.108|
                          DCD      0x40013800
                  |L9.112|
000070  0d0a00            DCB      "\r\n",0
000073  00                DCB      0
                  |L9.116|
                          DCD      0x00011940
                  |L9.120|
000078  08256400          DCB      "\b%d",0

                          AREA ||i.boot_backup||, CODE, READONLY, ALIGN=2

                  boot_backup PROC
;;;108    
;;;109    static void boot_backup(uint8_t *command)
000000  b53e              PUSH     {r1-r5,lr}
;;;110    {
000002  4604              MOV      r4,r0
;;;111        Imageargs_t iargs;
;;;112        if (GetImageInfo(&iargs, "SD") == STM32_SUCCESS) {
000004  a106              ADR      r1,|L10.32|
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       GetImageInfo
00000c  2801              CMP      r0,#1
00000e  d102              BNE      |L10.22|
;;;113            ImageCopySdToEep();
000010  f7fffffe          BL       ImageCopySdToEep
000014  e002              B        |L10.28|
                  |L10.22|
;;;114        } else {
;;;115            uartprintf("Could not find valid image at SD\r\n");
000016  a003              ADR      r0,|L10.36|
000018  f7fffffe          BL       uartprintf
                  |L10.28|
;;;116        }
;;;117        return;
;;;118    }
00001c  bd3e              POP      {r1-r5,pc}
;;;119    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
000020  534400            DCB      "SD",0
000023  00                DCB      0
                  |L10.36|
000024  436f756c          DCB      "Could not find valid image at SD\r\n",0
000028  64206e6f
00002c  74206669
000030  6e642076
000034  616c6964
000038  20696d61
00003c  67652061
000040  74205344
000044  0d0a00  
000047  00                DCB      0

                          AREA ||i.boot_printenv||, CODE, READONLY, ALIGN=2

                  boot_printenv PROC
;;;52     //==================================================================================
;;;53     static void boot_printenv(uint8_t *command)
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55         uartprintf("ImageSrcConfig=%s\r\n", Bootargs.confSrc);
000004  4907              LDR      r1,|L11.36|
000006  a008              ADR      r0,|L11.40|
000008  f7fffffe          BL       uartprintf
;;;56         uartprintf("ImageSrcState=%s\r\n",  Bootargs.statSrc);
00000c  4905              LDR      r1,|L11.36|
00000e  310a              ADDS     r1,r1,#0xa
000010  a00a              ADR      r0,|L11.60|
000012  f7fffffe          BL       uartprintf
;;;57         uartprintf("ImageVersion=%d\r\n",   Bootargs.version);
000016  4803              LDR      r0,|L11.36|
000018  1e80              SUBS     r0,r0,#2
00001a  6981              LDR      r1,[r0,#0x18]  ; Bootargs
00001c  a00c              ADR      r0,|L11.80|
00001e  f7fffffe          BL       uartprintf
;;;58     }
000022  bd10              POP      {r4,pc}
;;;59     
                          ENDP

                  |L11.36|
                          DCD      Bootargs+0x2
                  |L11.40|
000028  496d6167          DCB      "ImageSrcConfig=%s\r\n",0
00002c  65537263
000030  436f6e66
000034  69673d25
000038  730d0a00
                  |L11.60|
00003c  496d6167          DCB      "ImageSrcState=%s\r\n",0
000040  65537263
000044  53746174
000048  653d2573
00004c  0d0a00  
00004f  00                DCB      0
                  |L11.80|
000050  496d6167          DCB      "ImageVersion=%d\r\n",0
000054  65566572
000058  73696f6e
00005c  3d25640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.boot_saveenv||, CODE, READONLY, ALIGN=2

                  boot_saveenv PROC
;;;101    
;;;102    static void boot_saveenv(uint8_t *command)
000000  b510              PUSH     {r4,lr}
;;;103    {
000002  4604              MOV      r4,r0
;;;104        EEProm_SectorErrase(BOOTARGS_ADDR);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       EEProm_SectorErrase
;;;105        EEPROM_Write(BOOTARGS_ADDR, (uint8_t *) &Bootargs, sizeof(Bootargs_t));
00000a  2220              MOVS     r2,#0x20
00000c  4902              LDR      r1,|L12.24|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       EEPROM_Write
;;;106        return;
;;;107    }
000014  bd10              POP      {r4,pc}
;;;108    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      Bootargs

                          AREA ||i.boot_setenv||, CODE, READONLY, ALIGN=2

                  boot_setenv PROC
;;;59     
;;;60     static void boot_setenv(uint8_t *command)
000000  b570              PUSH     {r4-r6,lr}
;;;61     {
000002  4606              MOV      r6,r0
;;;62         uint8_t *name = NULL;
000004  2400              MOVS     r4,#0
;;;63         uint8_t *val = NULL;
000006  2500              MOVS     r5,#0
;;;64     
;;;65         if (command == NULL) {
000008  b91e              CBNZ     r6,|L13.18|
;;;66             uartprintf("Not a valid command\r\n");
00000a  a024              ADR      r0,|L13.156|
00000c  f7fffffe          BL       uartprintf
                  |L13.16|
;;;67             return;
;;;68         }
;;;69         
;;;70         name = (uint8_t *)strtok((char *)command, " ");
;;;71         if (name == NULL) {
;;;72             uartprintf("Please provide a command\r\n");
;;;73             return;
;;;74         }
;;;75         
;;;76         name = (uint8_t *)strtok(NULL, " ");
;;;77         if (name == NULL) {
;;;78             uartprintf("Please provide a parameter name\r\n");
;;;79             return;
;;;80         }
;;;81         
;;;82         val = (uint8_t *)strtok(NULL, " ");
;;;83         if (val == NULL) {
;;;84             uartprintf("Please provide a value\r\n");
;;;85             return;
;;;86         }
;;;87     
;;;88         if (strcmp((char *)name, "ImageSrcConfig") == 0) {
;;;89             strcpy((char *)Bootargs.confSrc, (char *)val);
;;;90         } else if (strcmp((char *)name, "ImageSrcState") == 0) {
;;;91             strcpy((char *)Bootargs.statSrc, (char *)val);
;;;92         } else if (strcmp((char *)name, "ImageVersion") == 0) {
;;;93             Bootargs.version = atoi((char *)val);
;;;94         } else {
;;;95             uartprintf("Not a valid parameter\r\n");
;;;96             return;
;;;97         }
;;;98         
;;;99         return;
;;;100    }
000010  bd70              POP      {r4-r6,pc}
                  |L13.18|
000012  a128              ADR      r1,|L13.180|
000014  4630              MOV      r0,r6                 ;70
000016  f7fffffe          BL       strtok
00001a  4604              MOV      r4,r0                 ;70
00001c  b91c              CBNZ     r4,|L13.38|
00001e  a026              ADR      r0,|L13.184|
000020  f7fffffe          BL       uartprintf
000024  e7f4              B        |L13.16|
                  |L13.38|
000026  a123              ADR      r1,|L13.180|
000028  2000              MOVS     r0,#0                 ;76
00002a  f7fffffe          BL       strtok
00002e  4604              MOV      r4,r0                 ;76
000030  b91c              CBNZ     r4,|L13.58|
000032  a028              ADR      r0,|L13.212|
000034  f7fffffe          BL       uartprintf
000038  e7ea              B        |L13.16|
                  |L13.58|
00003a  a11e              ADR      r1,|L13.180|
00003c  2000              MOVS     r0,#0                 ;82
00003e  f7fffffe          BL       strtok
000042  4605              MOV      r5,r0                 ;82
000044  b91d              CBNZ     r5,|L13.78|
000046  a02c              ADR      r0,|L13.248|
000048  f7fffffe          BL       uartprintf
00004c  e7e0              B        |L13.16|
                  |L13.78|
00004e  a131              ADR      r1,|L13.276|
000050  4620              MOV      r0,r4                 ;88
000052  f7fffffe          BL       strcmp
000056  b920              CBNZ     r0,|L13.98|
000058  4629              MOV      r1,r5                 ;89
00005a  4832              LDR      r0,|L13.292|
00005c  f7fffffe          BL       strcpy
000060  e01a              B        |L13.152|
                  |L13.98|
000062  a131              ADR      r1,|L13.296|
000064  4620              MOV      r0,r4                 ;90
000066  f7fffffe          BL       strcmp
00006a  b928              CBNZ     r0,|L13.120|
00006c  4629              MOV      r1,r5                 ;91
00006e  482d              LDR      r0,|L13.292|
000070  300a              ADDS     r0,r0,#0xa            ;91
000072  f7fffffe          BL       strcpy
000076  e00f              B        |L13.152|
                  |L13.120|
000078  a12f              ADR      r1,|L13.312|
00007a  4620              MOV      r0,r4                 ;92
00007c  f7fffffe          BL       strcmp
000080  b930              CBNZ     r0,|L13.144|
000082  4628              MOV      r0,r5                 ;93
000084  f7fffffe          BL       atoi
000088  4926              LDR      r1,|L13.292|
00008a  1e89              SUBS     r1,r1,#2              ;93
00008c  6188              STR      r0,[r1,#0x18]         ;93  ; Bootargs
00008e  e003              B        |L13.152|
                  |L13.144|
000090  a02d              ADR      r0,|L13.328|
000092  f7fffffe          BL       uartprintf
000096  e7bb              B        |L13.16|
                  |L13.152|
000098  bf00              NOP                            ;99
00009a  e7b9              B        |L13.16|
;;;101    
                          ENDP

                  |L13.156|
00009c  4e6f7420          DCB      "Not a valid command\r\n",0
0000a0  61207661
0000a4  6c696420
0000a8  636f6d6d
0000ac  616e640d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L13.180|
0000b4  2000              DCB      " ",0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L13.184|
0000b8  506c6561          DCB      "Please provide a command\r\n",0
0000bc  73652070
0000c0  726f7669
0000c4  64652061
0000c8  20636f6d
0000cc  6d616e64
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L13.212|
0000d4  506c6561          DCB      "Please provide a parameter name\r\n",0
0000d8  73652070
0000dc  726f7669
0000e0  64652061
0000e4  20706172
0000e8  616d6574
0000ec  6572206e
0000f0  616d650d
0000f4  0a00    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L13.248|
0000f8  506c6561          DCB      "Please provide a value\r\n",0
0000fc  73652070
000100  726f7669
000104  64652061
000108  2076616c
00010c  75650d0a
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L13.276|
000114  496d6167          DCB      "ImageSrcConfig",0
000118  65537263
00011c  436f6e66
000120  696700  
000123  00                DCB      0
                  |L13.292|
                          DCD      Bootargs+0x2
                  |L13.296|
000128  496d6167          DCB      "ImageSrcState",0
00012c  65537263
000130  53746174
000134  6500    
000136  00                DCB      0
000137  00                DCB      0
                  |L13.312|
000138  496d6167          DCB      "ImageVersion",0
00013c  65566572
000140  73696f6e
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L13.328|
000148  4e6f7420          DCB      "Not a valid parameter\r\n",0
00014c  61207661
000150  6c696420
000154  70617261
000158  6d657465
00015c  720d0a00

                          AREA ||i.bootm||, CODE, READONLY, ALIGN=2

                  bootm PROC
;;;320    
;;;321    void bootm(uint8_t *command)
000000  b53e              PUSH     {r1-r5,lr}
;;;322    {
000002  4605              MOV      r5,r0
;;;323        Imageargs_t iargs;
;;;324    	  uartprintf("\r\nBooting Image from (%s) ...\r\n", (char *)Bootargs.confSrc);
000004  493b              LDR      r1,|L14.244|
000006  a03c              ADR      r0,|L14.248|
000008  f7fffffe          BL       uartprintf
;;;325        memset(&iargs, 0, sizeof(Imageargs_t));
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  9001              STR      r0,[sp,#4]
000012  9002              STR      r0,[sp,#8]
;;;326        if (strcmp((char *)Bootargs.confSrc, (char *)Bootargs.statSrc) == 0) {
000014  4937              LDR      r1,|L14.244|
000016  310a              ADDS     r1,r1,#0xa
000018  4836              LDR      r0,|L14.244|
00001a  f7fffffe          BL       strcmp
00001e  2800              CMP      r0,#0
000020  d139              BNE      |L14.150|
;;;327            if ((strcmp((char *)Bootargs.confSrc, "EEPROM") == 0) ||
000022  a13d              ADR      r1,|L14.280|
000024  4833              LDR      r0,|L14.244|
000026  f7fffffe          BL       strcmp
00002a  b128              CBZ      r0,|L14.56|
;;;328                (strcmp((char *)Bootargs.confSrc, "SD") == 0)) {
00002c  a13c              ADR      r1,|L14.288|
00002e  4831              LDR      r0,|L14.244|
000030  f7fffffe          BL       strcmp
000034  2800              CMP      r0,#0
000036  d129              BNE      |L14.140|
                  |L14.56|
;;;329                if (GetImageInfo(&iargs, (uint8_t *)Bootargs.confSrc) == STM32_SUCCESS) {
000038  492e              LDR      r1,|L14.244|
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       GetImageInfo
000040  2801              CMP      r0,#1
000042  d11e              BNE      |L14.130|
;;;330                    if (Bootargs.version == iargs.version) {
000044  482b              LDR      r0,|L14.244|
000046  1e80              SUBS     r0,r0,#2
000048  6980              LDR      r0,[r0,#0x18]  ; Bootargs
00004a  f8bd1002          LDRH     r1,[sp,#2]
00004e  4288              CMP      r0,r1
000050  d102              BNE      |L14.88|
;;;331                        AppJump();
000052  f7fffffe          BL       AppJump
000056  e04c              B        |L14.242|
                  |L14.88|
;;;332                    } else {
;;;333                        if (strcmp((char *)Bootargs.confSrc, "EEPROM") == 0)
000058  a12f              ADR      r1,|L14.280|
00005a  4826              LDR      r0,|L14.244|
00005c  f7fffffe          BL       strcmp
000060  b910              CBNZ     r0,|L14.104|
;;;334                            ImageCopyEepToFlash();
000062  f7fffffe          BL       ImageCopyEepToFlash
000066  e001              B        |L14.108|
                  |L14.104|
;;;335                        else 
;;;336                            ImageCopySdToFlash();
000068  f7fffffe          BL       ImageCopySdToFlash
                  |L14.108|
;;;337                        Bootargs.version = iargs.version;
00006c  f8bd0002          LDRH     r0,[sp,#2]
000070  4920              LDR      r1,|L14.244|
000072  1e89              SUBS     r1,r1,#2
000074  6188              STR      r0,[r1,#0x18]  ; Bootargs
;;;338                        boot_saveenv(NULL);
000076  2000              MOVS     r0,#0
000078  f7fffffe          BL       boot_saveenv
;;;339                        AppJump();
00007c  f7fffffe          BL       AppJump
000080  e037              B        |L14.242|
                  |L14.130|
;;;340                    }
;;;341                } else {
;;;342                    uartprintf("Could not find valid image at (%s)\r\n", Bootargs.confSrc);
000082  491c              LDR      r1,|L14.244|
000084  a027              ADR      r0,|L14.292|
000086  f7fffffe          BL       uartprintf
00008a  e032              B        |L14.242|
                  |L14.140|
;;;343                }
;;;344            } else {
;;;345                uartprintf("Device (%s) is not valid\r\n", Bootargs.confSrc);
00008c  4919              LDR      r1,|L14.244|
00008e  a02f              ADR      r0,|L14.332|
000090  f7fffffe          BL       uartprintf
000094  e02d              B        |L14.242|
                  |L14.150|
;;;346            }
;;;347        } else {
;;;348            if (GetImageInfo(&iargs, (uint8_t *)Bootargs.confSrc) == STM32_SUCCESS) {
000096  4917              LDR      r1,|L14.244|
000098  4668              MOV      r0,sp
00009a  f7fffffe          BL       GetImageInfo
00009e  2801              CMP      r0,#1
0000a0  d123              BNE      |L14.234|
;;;349                memset((char *)Bootargs.statSrc, 0, MAX_SOURCE_STR_LEN);
0000a2  210a              MOVS     r1,#0xa
0000a4  4813              LDR      r0,|L14.244|
0000a6  300a              ADDS     r0,r0,#0xa
0000a8  f7fffffe          BL       __aeabi_memclr4
;;;350                memcpy((char *)Bootargs.statSrc, (char *)Bootargs.confSrc, strlen((char *)Bootargs.confSrc)+1);
0000ac  4811              LDR      r0,|L14.244|
0000ae  f7fffffe          BL       strlen
0000b2  1c44              ADDS     r4,r0,#1
0000b4  4622              MOV      r2,r4
0000b6  490f              LDR      r1,|L14.244|
0000b8  f101000a          ADD      r0,r1,#0xa
0000bc  f7fffffe          BL       __aeabi_memcpy
;;;351                Bootargs.version = iargs.version;
0000c0  f8bd0002          LDRH     r0,[sp,#2]
0000c4  490b              LDR      r1,|L14.244|
0000c6  1e89              SUBS     r1,r1,#2
0000c8  6188              STR      r0,[r1,#0x18]  ; Bootargs
;;;352    
;;;353                if (strcmp((char *)Bootargs.confSrc, "EEPROM") == 0)
0000ca  a113              ADR      r1,|L14.280|
0000cc  4809              LDR      r0,|L14.244|
0000ce  f7fffffe          BL       strcmp
0000d2  b910              CBNZ     r0,|L14.218|
;;;354                    ImageCopyEepToFlash();
0000d4  f7fffffe          BL       ImageCopyEepToFlash
0000d8  e001              B        |L14.222|
                  |L14.218|
;;;355                else 
;;;356                    ImageCopySdToFlash();
0000da  f7fffffe          BL       ImageCopySdToFlash
                  |L14.222|
;;;357                boot_saveenv(NULL);
0000de  2000              MOVS     r0,#0
0000e0  f7fffffe          BL       boot_saveenv
;;;358                AppJump();
0000e4  f7fffffe          BL       AppJump
0000e8  e003              B        |L14.242|
                  |L14.234|
;;;359            } else {
;;;360                uartprintf("Could not find valid image at (%s)\r\n", Bootargs.confSrc);
0000ea  4902              LDR      r1,|L14.244|
0000ec  a00d              ADR      r0,|L14.292|
0000ee  f7fffffe          BL       uartprintf
                  |L14.242|
;;;361            }
;;;362        }
;;;363    }
0000f2  bd3e              POP      {r1-r5,pc}
;;;364    
                          ENDP

                  |L14.244|
                          DCD      Bootargs+0x2
                  |L14.248|
0000f8  0d0a426f          DCB      "\r\nBooting Image from (%s) ...\r\n",0
0000fc  6f74696e
000100  6720496d
000104  61676520
000108  66726f6d
00010c  20282573
000110  29202e2e
000114  2e0d0a00
                  |L14.280|
000118  45455052          DCB      "EEPROM",0
00011c  4f4d00  
00011f  00                DCB      0
                  |L14.288|
000120  534400            DCB      "SD",0
000123  00                DCB      0
                  |L14.292|
000124  436f756c          DCB      "Could not find valid image at (%s)\r\n",0
000128  64206e6f
00012c  74206669
000130  6e642076
000134  616c6964
000138  20696d61
00013c  67652061
000140  74202825
000144  73290d0a
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L14.332|
00014c  44657669          DCB      "Device (%s) is not valid\r\n",0
000150  63652028
000154  25732920
000158  6973206e
00015c  6f742076
000160  616c6964
000164  0d0a00  
000167  00                DCB      0

                          AREA ||i.execute_command||, CODE, READONLY, ALIGN=2

                  execute_command PROC
;;;364    
;;;365    void execute_command(uint8_t *command)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;366    {
000004  4606              MOV      r6,r0
;;;367        int i;
;;;368        const cmdType_t *cmdType;
;;;369        for (i=0;i<NUM_ROWS(commands);i++) {
000006  2400              MOVS     r4,#0
000008  e012              B        |L15.48|
                  |L15.10|
;;;370            cmdType = &commands[i];
00000a  480d              LDR      r0,|L15.64|
00000c  eb001504          ADD      r5,r0,r4,LSL #4
;;;371            if (strncmp((char *)cmdType->name, (char *)command, strlen((char *)cmdType->name)) == 0) {
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       strlen
000016  4607              MOV      r7,r0
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       strncmp
000022  b920              CBNZ     r0,|L15.46|
;;;372                cmdType->func(command);
000024  4630              MOV      r0,r6
000026  68e9              LDR      r1,[r5,#0xc]
000028  4788              BLX      r1
                  |L15.42|
;;;373                return;
;;;374            }
;;;375        }
;;;376        boot_printenv(command);
;;;377        return;
;;;378    }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L15.46|
00002e  1c64              ADDS     r4,r4,#1              ;369
                  |L15.48|
000030  2c05              CMP      r4,#5                 ;369
000032  d3ea              BCC      |L15.10|
000034  4630              MOV      r0,r6                 ;376
000036  f7fffffe          BL       boot_printenv
00003a  bf00              NOP                            ;377
00003c  e7f5              B        |L15.42|
;;;379    
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      commands

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Bootargs
                          %        32
                  ImageBuf
                          %        512

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  commands
000000  7072696e          DCB      0x70,0x72,0x69,0x6e
000004  74656e76          DCB      0x74,0x65,0x6e,0x76
000008  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      boot_printenv
000010  73657465          DCB      0x73,0x65,0x74,0x65
000014  6e760000          DCB      0x6e,0x76,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      boot_setenv
000020  73617665          DCB      0x73,0x61,0x76,0x65
000024  656e7600          DCB      0x65,0x6e,0x76,0x00
000028  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      boot_saveenv
000030  6261636b          DCB      0x62,0x61,0x63,0x6b
000034  75700000          DCB      0x75,0x70,0x00,0x00
000038  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      boot_backup
000040  626f6f74          DCB      0x62,0x6f,0x6f,0x74
000044  6d000000          DCB      0x6d,0x00,0x00,0x00
000048  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      bootm

                          AREA ||.data||, DATA, ALIGN=2

                  JumpToApplication
                          DCD      0x00000000
                  JumpAddress
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Core\\Src\\boot.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_boot_c_62351056____REV16|
#line 388 ".\\Core\\Inc\\cmsis_armcc.h"
|__asm___6_boot_c_62351056____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_boot_c_62351056____REVSH|
#line 402
|__asm___6_boot_c_62351056____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_boot_c_62351056____RRX|
#line 587
|__asm___6_boot_c_62351056____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
