#include "driver.hpp"
#include "stm32f1xx.h"

//const GPIO_PINS_t LedPin = 
const std::list<GPIO_PINS_t> iLowPinList (
    {
    // Led
    {GPIOB, GPIO_BSRR_BS5,  (GPIO_CRL_CNF5 | GPIO_CRL_MODE5), GPIO_CRL_MODE5_1},

    // EEPROM CS
    {GPIOA, GPIO_BSRR_BS4,  (GPIO_CRL_CNF4 | GPIO_CRL_MODE4), GPIO_CRL_MODE4},

    // spi1
    {GPIOA, GPIO_BSRR_BS5,  (GPIO_CRL_CNF5  | GPIO_CRL_MODE5),  (GPIO_CRL_CNF5_1  | GPIO_CRL_MODE5)},
    {GPIOA, GPIO_BSRR_BS6,  (GPIO_CRL_CNF6  | GPIO_CRL_MODE6),  GPIO_CRL_CNF6_0},
    {GPIOA, GPIO_BSRR_BS7,  (GPIO_CRL_CNF7  | GPIO_CRL_MODE7),  (GPIO_CRL_CNF7_1  | GPIO_CRL_MODE7)},
    
    // FSMC
    {GPIOE, GPIO_BSRR_BS1,  (GPIO_CRL_CNF1  | GPIO_CRL_MODE1),  GPIO_CRL_MODE1_1},
    {GPIOE, GPIO_BSRR_BS7,  (GPIO_CRL_CNF7  | GPIO_CRL_MODE7),  (GPIO_CRL_CNF7_1  | GPIO_CRL_MODE7)},
    {GPIOD, GPIO_BSRR_BS0,  (GPIO_CRL_CNF0  | GPIO_CRL_MODE0),  (GPIO_CRL_CNF0_1  | GPIO_CRL_MODE0)},
    {GPIOD, GPIO_BSRR_BS1,  (GPIO_CRL_CNF1  | GPIO_CRL_MODE1),  (GPIO_CRL_CNF1_1  | GPIO_CRL_MODE1)},
    {GPIOD, GPIO_BSRR_BS4,  (GPIO_CRL_CNF4  | GPIO_CRL_MODE4),  (GPIO_CRL_CNF4_1  | GPIO_CRL_MODE4)},
    {GPIOD, GPIO_BSRR_BS5,  (GPIO_CRL_CNF5  | GPIO_CRL_MODE5),  (GPIO_CRL_CNF5_1  | GPIO_CRL_MODE5)},
    {GPIOD, GPIO_BSRR_BS7,  (GPIO_CRL_CNF7  | GPIO_CRL_MODE7),  (GPIO_CRL_CNF7_1  | GPIO_CRL_MODE7)},

    // sdio
    {GPIOD, GPIO_BSRR_BS2,  (GPIO_CRL_CNF2  | GPIO_CRL_MODE2),  (GPIO_CRL_CNF2_1  | GPIO_CRL_MODE2)}
    }
);
const std::list<GPIO_PINS_t> iHighPinList (
    {
    // usart1
    {GPIOA, GPIO_BSRR_BS9,  (GPIO_CRH_CNF9  | GPIO_CRH_MODE9),  (GPIO_CRH_CNF9_1  | GPIO_CRH_MODE9)},
    {GPIOA, GPIO_BSRR_BS10, (GPIO_CRH_CNF10 | GPIO_CRH_MODE10), GPIO_CRH_CNF10_0},
    
    // FSMC
    {GPIOD, GPIO_BSRR_BS13, (GPIO_CRH_CNF13 | GPIO_CRH_MODE13), GPIO_CRH_MODE13},
    {GPIOD, GPIO_BSRR_BS8,  (GPIO_CRH_CNF8  | GPIO_CRH_MODE8),  (GPIO_CRH_CNF8_1  | GPIO_CRH_MODE8)},
    {GPIOD, GPIO_BSRR_BS9,  (GPIO_CRH_CNF9  | GPIO_CRH_MODE9),  (GPIO_CRH_CNF9_1  | GPIO_CRH_MODE9)},
    {GPIOD, GPIO_BSRR_BS10, (GPIO_CRH_CNF10 | GPIO_CRH_MODE10), (GPIO_CRH_CNF10_1 | GPIO_CRH_MODE10)},
    {GPIOD, GPIO_BSRR_BS11, (GPIO_CRH_CNF11 | GPIO_CRH_MODE11), (GPIO_CRH_CNF11_1 | GPIO_CRH_MODE11)},
    {GPIOD, GPIO_BSRR_BS14, (GPIO_CRH_CNF14 | GPIO_CRH_MODE14), (GPIO_CRH_CNF14_1 | GPIO_CRH_MODE14)},
    {GPIOD, GPIO_BSRR_BS15, (GPIO_CRH_CNF15 | GPIO_CRH_MODE15), (GPIO_CRH_CNF15_1 | GPIO_CRH_MODE15)},
    {GPIOE, GPIO_BSRR_BS8,  (GPIO_CRH_CNF8  | GPIO_CRH_MODE8),  (GPIO_CRH_CNF8_1  | GPIO_CRH_MODE8)},
    {GPIOE, GPIO_BSRR_BS9,  (GPIO_CRH_CNF9  | GPIO_CRH_MODE9),  (GPIO_CRH_CNF9_1  | GPIO_CRH_MODE9)},
    {GPIOE, GPIO_BSRR_BS10, (GPIO_CRH_CNF10 | GPIO_CRH_MODE10), (GPIO_CRH_CNF10_1 | GPIO_CRH_MODE10)},
    {GPIOE, GPIO_BSRR_BS11, (GPIO_CRH_CNF11 | GPIO_CRH_MODE11), (GPIO_CRH_CNF11_1 | GPIO_CRH_MODE11)},
    {GPIOE, GPIO_BSRR_BS12, (GPIO_CRH_CNF12 | GPIO_CRH_MODE12), (GPIO_CRH_CNF12_1 | GPIO_CRH_MODE12)},
    {GPIOE, GPIO_BSRR_BS13, (GPIO_CRH_CNF13 | GPIO_CRH_MODE13), (GPIO_CRH_CNF13_1 | GPIO_CRH_MODE13)},
    {GPIOE, GPIO_BSRR_BS14, (GPIO_CRH_CNF14 | GPIO_CRH_MODE14), (GPIO_CRH_CNF14_1 | GPIO_CRH_MODE14)},
    {GPIOE, GPIO_BSRR_BS15, (GPIO_CRH_CNF15 | GPIO_CRH_MODE15), (GPIO_CRH_CNF15_1 | GPIO_CRH_MODE15)},

    // sdio
    {GPIOC, GPIO_BSRR_BS8,  (GPIO_CRH_CNF8  | GPIO_CRH_MODE8),  (GPIO_CRH_CNF8_1  | GPIO_CRH_MODE8)},
    {GPIOC, GPIO_BSRR_BS9,  (GPIO_CRH_CNF9  | GPIO_CRH_MODE9),  (GPIO_CRH_CNF9_1  | GPIO_CRH_MODE9)},
    {GPIOC, GPIO_BSRR_BS10, (GPIO_CRH_CNF10 | GPIO_CRH_MODE10), (GPIO_CRH_CNF10_1 | GPIO_CRH_MODE10)},
    {GPIOC, GPIO_BSRR_BS11, (GPIO_CRH_CNF11 | GPIO_CRH_MODE11), (GPIO_CRH_CNF11_1 | GPIO_CRH_MODE11)},
    {GPIOC, GPIO_BSRR_BS12, (GPIO_CRH_CNF12 | GPIO_CRH_MODE12), (GPIO_CRH_CNF12_1 | GPIO_CRH_MODE12)}
    }
);

STM32F103VET_RCC::STM32F103VET_RCC()
{
    FLASH->ACR |= FLASH_ACR_PRFTBE;
    NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
    SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);

    CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
    SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_DISABLE);

    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_1);

    SET_BIT(RCC->CR, RCC_CR_HSEON);
    while(!READ_BIT(RCC->CR, RCC_CR_HSERDY));

    SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
    while(!READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY));

    MODIFY_REG(RCC->CFGR, (RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL),
             (RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL9));

    // 1£º PLLÊ¹ÄÜ¡£
    SET_BIT(RCC->CR, RCC_CR_PLLON);
    while(!READ_BIT(RCC->CR, RCC_CR_PLLRDY));

    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
    while((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS)) != RCC_CFGR_SWS_PLL);

    SystemCoreClock = 72000000;

    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN);
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN);
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPDEN);
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPEEN);
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN);
    SET_BIT(RCC->AHBENR,  RCC_AHBENR_SDIOEN);
    SET_BIT(RCC->AHBENR,  RCC_AHBENR_FSMCEN);
    SET_BIT(RCC->APB1ENR, RCC_APB1ENR_BKPEN);
}

STM32F103VET_IO::STM32F103VET_IO()
{
    for (auto pin : iLowPinList) {
        WRITE_REG(pin.port->BRR, pin.pin);
        MODIFY_REG(pin.port->CRL, pin.clear, pin.set); 
        MODIFY_REG(pin.port->ODR, pin.pin, 0);
    }
    
    for (auto pin : iHighPinList) {
        WRITE_REG(pin.port->BRR, pin.pin);
        MODIFY_REG(pin.port->CRH, pin.clear, pin.set); 
        MODIFY_REG(pin.port->ODR, pin.pin, 0);
    }
}

Timer::Timer(TIM_TypeDef *TIMx,  uint32_t Periphs, IRQn_Type IRQn)
{
    if ((TIMx == TIM1) || (TIMx == TIM8)) {
        SET_BIT(RCC->APB2ENR, Periphs);
    } else {
        SET_BIT(RCC->APB1ENR, Periphs);
    }

    /*清空计数器的值*/
    WRITE_REG(TIMx->CNT, 0);
    WRITE_REG(TIMx->ARR, 2000-(TIM_CCMR1_IC1F_0 << 16U));
    WRITE_REG(TIMx->PSC, 36000-(TIM_CCMR1_IC1F_0 << 16U));

    WRITE_REG(TIMx->CR1, 0); //将控制寄存器1清空

    SET_BIT(TIMx->CR1, TIM_CR1_URS); //设置事件更新请求源

    /*设置无缓冲功能*/
    CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);

    /*设置循环模式*/
    CLEAR_BIT(TIMx->CR1, TIM_CR1_OPM);

    /*允许更新中断使能*/
    SET_BIT(TIMx->DIER, TIM_DIER_UIE);

    /*使能基本定时器中断*/
    NVIC_EnableIRQ(IRQn);

    /*开启计数器使能*/
    SET_BIT(TIMx->CR1, TIM_CR1_CEN);
}

STM32F103VET_USART::STM32F103VET_USART()
{
    if (READ_BIT(USART1->CR1, USART_CR1_UE) != (USART_CR1_UE)) {
        MODIFY_REG(USART1->CR1,
               (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
               (USART_CR1_TE |USART_CR1_RE));

        MODIFY_REG(USART1->CR2, USART_CR2_STOP, 0);

        MODIFY_REG(USART1->CR3, USART_CR3_RTSE | USART_CR3_CTSE, 0);

        USART1->BRR = 0x271;
    }
        
    CLEAR_BIT(USART1->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
    CLEAR_BIT(USART1->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
        
    SET_BIT(USART1->CR1, USART_CR1_UE);
    SET_BIT(USART1->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));

    NVIC_EnableIRQ(USART1_IRQn);
}

STM32F103VET_RTC::STM32F103VET_RTC()
{
    SET_BIT(PWR->CR, PWR_CR_DBP);
    SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);

    CLEAR_BIT(RTC->CRL, RTC_CRL_RSF);
    while (READ_BIT(RTC->CRL, RTC_CRL_RSF)) {}

    while (!READ_BIT(RTC->CRL, RTC_CRL_RTOFF)) {}
    SET_BIT(RTC->CRL, RTC_CRL_CNF);
    
    MODIFY_REG(RTC->PRLH, RTC_PRLH_PRL, (0xFFFFFFFFU >> 16));
    MODIFY_REG(RTC->PRLL, RTC_PRLL_PRL, (0xFFFFFFFFU & RTC_PRLL_PRL));
    
    while (!READ_BIT(RTC->CRL, RTC_CRL_RTOFF)) {}
    SET_BIT(RTC->CRL, RTC_CRL_CNF);

    uint32_t time = ((uint32_t)16 * 3600U) + ((uint32_t)50 * 60U);
    /* Set RTC COUNTER MSB word */
    WRITE_REG(RTC->CNTH, (time >> 16U));
    /* Set RTC COUNTER LSB word */
    WRITE_REG(RTC->CNTL, (time & RTC_CNTL_RTC_CNT));

    CLEAR_BIT(RTC->CRL, RTC_CRL_CNF);
    while (!READ_BIT(RTC->CRL, RTC_CRL_RTOFF)) {}
}

STM32F103VET_FSMC::STM32F103VET_FSMC()
{
    /* Initialize SRAM control Interface */
    CLEAR_BIT(FSMC_Bank1->BTCR[0], FSMC_BCRx_MBKEN);

    MODIFY_REG(FSMC_Bank1->BTCR[0], (uint32_t)(FSMC_BCRx_FACCEN | FSMC_BCRx_MUXEN | FSMC_BCRx_MTYP |
                FSMC_BCRx_MWID | FSMC_BCRx_BURSTEN | FSMC_BCRx_WAITPOL | FSMC_BCRx_WRAPMOD |
                FSMC_BCRx_WAITCFG | FSMC_BCRx_WREN | FSMC_BCRx_WAITEN | FSMC_BCRx_EXTMOD |
                FSMC_BCRx_ASYNCWAIT | FSMC_BCRx_CBURSTRW), (uint32_t)(FSMC_BCRx_MWID_0 | FSMC_BCRx_WREN));

    /* Initialize SRAM timing Interface */
    MODIFY_REG(FSMC_Bank1->BTCR[1U], (uint32_t)(FSMC_BTRx_ADDSET | FSMC_BTRx_ADDHLD | FSMC_BTRx_DATAST |
                FSMC_BTRx_BUSTURN | FSMC_BTRx_CLKDIV | FSMC_BTRx_DATLAT | FSMC_BTRx_ACCMOD),                                                                \
                (uint32_t)(0x2 | (15 << FSMC_BTRx_ADDHLD_Pos) | (0x5 << FSMC_BTRx_DATAST_Pos) |
                        ((16 - 1U) << FSMC_BTRx_CLKDIV_Pos) | ((17 - 2U) << FSMC_BTRx_DATLAT_Pos)));

    /* Initialize SRAM extended mode timing Interface */
    FSMC_Bank1E->BWTR[0] = 0x0FFFFFFFU;

    /* Enable the NORSRAM device */
    SET_BIT(FSMC_Bank1->BTCR[0], FSMC_BCRx_MBKEN);

    SET_BIT(AFIO->MAPR2, AFIO_MAPR2_FSMC_NADV_REMAP);
}

STM32F103VET::STM32F103VET()
{
    iRCC.reset(new STM32F103VET_RCC());
    iIO.reset(new STM32F103VET_IO());
    
    auto AddTimer = [&] (TIM_TypeDef *TIMx,  uint32_t Periphs, IRQn_Type IRQn) {
        iTimers.emplace_back(new Timer(TIMx,  Periphs, IRQn));
    };
    
    AddTimer(TIM1, RCC_APB2ENR_TIM1EN, TIM1_UP_IRQn);
    AddTimer(TIM2, RCC_APB1ENR_TIM2EN, TIM2_IRQn);
    AddTimer(TIM3, RCC_APB1ENR_TIM3EN, TIM3_IRQn);
    AddTimer(TIM4, RCC_APB1ENR_TIM4EN, TIM4_IRQn);
    AddTimer(TIM5, RCC_APB1ENR_TIM5EN, TIM5_IRQn);
    AddTimer(TIM6, RCC_APB1ENR_TIM6EN, TIM6_IRQn);
    AddTimer(TIM7, RCC_APB1ENR_TIM7EN, TIM7_IRQn);
    AddTimer(TIM8, RCC_APB2ENR_TIM8EN, TIM8_UP_IRQn);
    
    iUsart.reset(new STM32F103VET_USART());
    iSpi.reset(new STM32F103VET_SPI());
    
#ifdef BOARD_ADV1
    iRtc.reset(new STM32F103VET_RTC());
    iDMA.reset(new STM32F103VET_DMA());
#endif
    
    iFSMC.reset(new STM32F103VET_FSMC());
    iLcd.reset(new HX8347D());
    iSd.reset(new STM32F103VET_SD());
    iEEPROM.reset(new SST25VF016B(iSpi, iLcd));
    
    for (int i=0;i<7200000;++i) {}
    iLcd->print("Start application");
}
